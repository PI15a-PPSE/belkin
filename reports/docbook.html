<html xmlns:ng="http://docbook.org/docbook-ng"><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>&#1055;&#1088;&#1086;&#1075;&#1088;&#1072;&#1084;&#1084;&#1085;&#1099;&#1081; &#1055;&#1088;&#1086;&#1076;&#1091;&#1082;&#1090; "Tic-Tac-Toe"</title><meta name="generator" content="DocBook XSL Stylesheets V1.79.2"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="article"><div class="titlepage"><div><div><h1 class="title"><a name="d5e1"></a>&#1055;&#1088;&#1086;&#1075;&#1088;&#1072;&#1084;&#1084;&#1085;&#1099;&#1081; &#1055;&#1088;&#1086;&#1076;&#1091;&#1082;&#1090; "Tic-Tac-Toe"</h1></div><div><div class="author"><h3 class="author"><span class="firstname">Dmitry</span> <span class="surname">Belkin</span></h3><div class="affiliation"><span class="orgname">Belkin Dmitry Org.<br></span></div></div></div><div><p class="pubdate">01-06-2018</p></div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="#d5e11">&#1054;&#1087;&#1080;&#1089;&#1072;&#1085;&#1080;&#1077; &#1087;&#1088;&#1086;&#1076;&#1091;&#1082;&#1090;&#1072;</a></span></dt><dt><span class="section"><a href="#d5e15">&#1055;&#1077;&#1088;&#1074;&#1099;&#1081; &#1079;&#1072;&#1087;&#1091;&#1089;&#1082;</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e11"></a>&#1054;&#1087;&#1080;&#1089;&#1072;&#1085;&#1080;&#1077; &#1087;&#1088;&#1086;&#1076;&#1091;&#1082;&#1090;&#1072;</h2></div></div></div><p>&#1055;&#1088;&#1086;&#1075;&#1088;&#1072;&#1084;&#1084;&#1085;&#1099;&#1081; &#1087;&#1088;&#1086;&#1076;&#1091;&#1082;&#1090; <span class="bold"><strong>Rubik's Cube</strong></span>&#1073;&#1099;&#1083;
    &#1088;&#1072;&#1079;&#1088;&#1072;&#1073;&#1086;&#1090;&#1072;&#1085; &#1076;&#1083;&#1103; &#1088;&#1072;&#1079;&#1074;&#1083;&#1077;&#1095;&#1077;&#1085;&#1080;&#1103;. &#1048;&#1075;&#1088;&#1072; &#1089;&#1086;&#1076;&#1077;&#1088;&#1078;&#1080;&#1090; &#1074; &#1089;&#1077;&#1073;&#1077; &#1082;&#1091;&#1073;&#1080;&#1082; &#1088;&#1091;&#1073;&#1080;&#1082;&#1072; 3&#1093;3
    &#1076;&#1083;&#1103; &#1086;&#1076;&#1085;&#1086;&#1075;&#1086; &#1080;&#1075;&#1088;&#1086;&#1082;&#1072;.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e15"></a>&#1055;&#1077;&#1088;&#1074;&#1099;&#1081; &#1079;&#1072;&#1087;&#1091;&#1089;&#1082;</h2></div></div></div><p>&#1055;&#1088;&#1080; &#1087;&#1077;&#1088;&#1074;&#1086;&#1084; &#1079;&#1072;&#1087;&#1091;&#1089;&#1082;&#1077; &#1080;&#1075;&#1088;&#1099; &#1087;&#1086;&#1083;&#1100;&#1079;&#1086;&#1074;&#1072;&#1090;&#1077;&#1083;&#1102; &#1087;&#1088;&#1077;&#1076;&#1086;&#1089;&#1090;&#1072;&#1074;&#1083;&#1077;&#1085; 3D &#1082;&#1091;&#1073;&#1080;&#1082;-&#1088;&#1091;&#1073;&#1080;&#1082;&#1072; &#1089; &#1087;&#1086;&#1076;&#1089;&#1082;&#1072;&#1079;&#1082;&#1086;&#1081;, &#1082;&#1086;&#1090;&#1086;&#1088;&#1072;&#1103; &#1089;&#1086;&#1076;&#1077;&#1088;&#1078;&#1080;&#1090;
    &#1091;&#1087;&#1088;&#1072;&#1074;&#1083;&#1077;&#1085;&#1080;&#1077;, &#1076;&#1074;&#1080;&#1078;&#1077;&#1085;&#1080;&#1103; &#1082;&#1091;&#1073;&#1080;&#1082;&#1072; &#1086;&#1073;&#1088;&#1072;&#1073;&#1072;&#1090;&#1099;&#1074;&#1072;&#1077;&#1090;&#1089;&#1103; &#1089;&#1083;&#1077;&#1076;&#1091;&#1102;&#1097;&#1077;&#1081;
    &#1092;&#1091;&#1085;&#1082;&#1094;&#1080;&#1077;&#1081;:</p><pre class="programlisting">cubeApp.makeMove = function(move, direction){
	var angle = Math.PI/4 * direction // Rotation amount
	if(move == 'r' || move == 'l'){ // Left or right vertical move
		var xPos = -10;
		if(move == 'r'){
			xPos = -6;
		}
		if(this.prevMove != move || this.prevMove == undefined){ // Add correct cubes if necessary
			this.active = []
			for(var i = 0; i less than this.rubiksCube.children.length; i ++){
				if(this.rubiksCube.children[i].position.x less than (xPos + 1) and this.rubiksCube.children[i].position.x more than (xPos - 1)){
					this.active.push(this.rubiksCube.children[i]);
				}
			}
		}
		this.pivotFace.rotation.set( 0, 0, 0 );
		this.pivotFace.updateMatrixWorld();

		for ( var i in this.active ) { //Attach cubes to pivotFace from cube
	    	THREE.SceneUtils.attach( this.active[ i ], this.rubiksCube, this.pivotFace );
		}
		this.pivotFace.rotateX(angle) //Perform rotation
	}


}</pre><p>&#1053;&#1072;&#1078;&#1072;&#1090;&#1080;&#1077; &#1082;&#1083;&#1072;&#1074;&#1080;&#1096; &#1086;&#1073;&#1088;&#1072;&#1073;&#1072;&#1090;&#1099;&#1074;&#1072;&#1077;&#1090;&#1089;&#1103; &#1085;&#1080;&#1078;&#1077;:</p><pre class="programlisting">cubeApp.onKeyDown = function(evt, solve){
	if(evt.code == "ShiftLeft" || evt.code == 'ShiftRight'){ //Reverse direction
		this.direction = -1*this.direction;
	}
	switch(evt.code){
		case "KeyU":
			if(this.locked[0] != true){ // Make sure face isn't locked
				this.uRot += 45; // Update rotation amount (for screen text)
				if(solve != true){ // If theyre not trying to solve, push it to stack
					this.stack.push({move: 'u', direction: this.direction})
				}
				this.makeMove('u',this.direction) //Make the move
				if(this.uRot % 90 != 0){ //If it isnt rotate at a 90 degree angle
					this.lockFaces(0); // Lock all the other faces
				}
				else{
					this.unlockFaces(); //Otherwise, unlike the other faces
				}
			}
			break;
		case "KeyD":
			if(this.locked[1] != true){
				this.dRot += 45;
				if(solve != true){
					this.stack.push({move: 'd', direction: this.direction})
				}
				this.makeMove('d',this.direction)
				if(this.dRot % 90 != 0){
					this.lockFaces(1);
				}
				else{
					this.unlockFaces();
				}
			}
			break;
		case "KeyR":
			if(this.locked[2] != true){
				this.rRot += 45;
				if(solve != true){
					this.stack.push({move: 'r', direction: this.direction})
				}
				this.makeMove('r',this.direction)
				if(this.rRot % 90 != 0){
					this.lockFaces(2);
				}
				else{
					this.unlockFaces();
				}
			}
			break;
		case "KeyL":
			if(this.locked[3] != true){
				this.lRot += 45;
				if(solve != true){
					this.stack.push( {move: 'l', direction: this.direction} )
				}
				this.makeMove('l',this.direction)
				if(this.lRot % 90 != 0){
					this.lockFaces(3);
				}
				else{
					this.unlockFaces();
				}
			}
			break;
		case "KeyF":
			if(this.locked[4] != true){
				this.fRot += 45;
				if(solve != true){
					this.stack.push({move: 'f',direction: this.direction})
				}
				this.makeMove('f',-1 * this.direction)
				if(this.fRot % 90 != 0){
					this.lockFaces(4);
				}
				else{
					this.unlockFaces();
				}
			}
			break;
		case "KeyB":
			if(this.locked[5] != true){
				this.bRot += 45;
				if(solve != true){
					this.stack.push({move: 'b',direction: this.direction})
				}
				this.makeMove('b',(-1 *this.direction))
				if(this.bRot % 90 != 0){
					this.lockFaces(5);
				}
				else{
					this.unlockFaces();
				}
			}
			break;
		case "ArrowLeft": //Update camera to new position
			this.camera.position.y = 7;
			this.camera.position.x = -20
			this.camera.lookAt(new THREE.Vector3(0,0,1)) //reset vector
			break;
		case "ArrowRight": //Update camera to new position		 
			this.camera.position.y = 7;
			this.camera.position.x = 20
			this.camera.lookAt(new THREE.Vector3(0,0,1)) //reset vector
			break;
		case "ArrowUp": //Update camera to new position
			this.camera.position.y = 10;
			this.camera.position.x = 0;
			this.camera.lookAt(new THREE.Vector3(0,0,1)) //reset vector
			break;
		case "ArrowDown": //Update camera to new position
			this.camera.position.y = -10;
			this.camera.position.x = 0;
			this.camera.lookAt(new THREE.Vector3(0,0,1)) //reset vector
			break;
		case "KeyS": //Turn scramble on/off
			this.scramble = !this.scramble;
			break;
		case "KeyA": // Start 360 degree rotation
			this.animate = true;
			this.lockFaces();
			break;
		case "Enter": //Start solve
			this.solve = true;
			break;
	}
}</pre><p>&#1058;&#1072;&#1082; &#1078;&#1077; &#1074; &#1080;&#1075;&#1088;&#1077; &#1087;&#1088;&#1080;&#1089;&#1091;&#1090;&#1089;&#1090;&#1074;&#1091;&#1077;&#1090; &#1072;&#1074;&#1090;&#1086;-&#1087;&#1088;&#1086;&#1093;&#1086;&#1078;&#1076;&#1077;&#1085;&#1080;&#1077;, &#1082;&#1086;&#1076; &#1087;&#1088;&#1077;&#1076;&#1086;&#1089;&#1090;&#1072;&#1074;&#1083;&#1077;&#1085; &#1085;&#1080;&#1078;&#1077;:</p><pre class="programlisting">cubeApp.solveCube = function(){
	var move = this.stack[this.stack.length-1].move; //Pop top move off stack
	var direction = this.stack[this.stack.length-1].direction;  //Pop top direction off stack
	this.stack.splice(this.stack.length-1) // Remove from stack
	if(direction == -1){ //set direction to opposite of move's
		this.direction = 1;
	}
	else{
		this.direction = -1;
	}
	// Make necessary move and set "solve" to true
	if(move == 'r'){
		this.rRot -= 90;
		this.onKeyDown({code : 'KeyR'}, true)
	}
	if(move == 'l'){
		this.lRot -= 90;
		this.onKeyDown({code : 'KeyL'}, true)
	}
	if(move == 'u'){
		this.uRot -= 90;
		this.onKeyDown({code : 'KeyU'}, true)
	}
	if(move == 'd'){
		this.dRot -= 90;
		this.onKeyDown({code : 'KeyD'}, true)
	}
	if(move == 'f'){
		this.fRot -= 90;
		this.onKeyDown({code : 'KeyF'}, true)
	}
	if(move == 'b'){
		this.bRot -= 90;
		this.onKeyDown({code : 'KeyB'}, true)
	}
}</pre><p>&#1058;&#1072;&#1082;&#1080;&#1084; &#1086;&#1073;&#1088;&#1072;&#1079;&#1086;&#1084;, &#1073;&#1099;&#1083;&#1086; &#1088;&#1072;&#1089;&#1089;&#1084;&#1086;&#1090;&#1088;&#1077;&#1085;&#1086; 3 &#1074;&#1072;&#1088;&#1080;&#1072;&#1085;&#1090;&#1072; &#1088;&#1072;&#1079;&#1074;&#1080;&#1090;&#1080;&#1103; &#1089;&#1086;&#1073;&#1099;&#1090;&#1080;&#1081;, &#1089;
    &#1087;&#1088;&#1080;&#1074;&#1077;&#1076;&#1077;&#1085;&#1085;&#1099;&#1084; &#1082;&#1086;&#1076;&#1086;&#1084;.</p></div></div></body></html>